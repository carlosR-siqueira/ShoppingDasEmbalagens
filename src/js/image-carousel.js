/**
 * Sistema de Troca de Imagens para Cards de Produtos
 * Muda apenas o src da imagem quando o mouse estiver sobre o card
 * Inclui cards normais e relacionados, sem interferir no carrossel principal
 */

console.log('üîÑ Carregando sistema de troca de imagens...');

class ImageCarousel {
    constructor() {
        this.carousels = new Map();
        this.intervalTime = 2000; // 2 segundos entre as trocas
        this.init();
    }

    init() {
        console.log('üöÄ Inicializando sistema de troca de imagens...');
        
        // Aguardar o carregamento completo da p√°gina
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupCarousels());
        } else {
            this.setupCarousels();
        }
    }

    setupCarousels() {
        console.log('üîç Procurando cards de produtos...');
        // Buscar todos os cards de produtos (incluindo relacionados)
        const productCards = document.querySelectorAll('.card, .related-card');
        console.log(`üì¶ Encontrados ${productCards.length} cards`);
        
        productCards.forEach((card, index) => {
            this.setupCardCarousel(card, index);
        });

        // Observar mudan√ßas no DOM para novos cards
        this.observeNewCards();
    }

    setupCardCarousel(card, cardIndex) {
        const img = card.querySelector('.card-img-top');
        
        if (!img) {
            console.log(`‚ùå Card ${cardIndex}: Imagem n√£o encontrada`);
            return;
        }

        console.log(`‚úÖ Card ${cardIndex}: Configurando troca de imagens...`);
        
        // Verificar se o produto tem m√∫ltiplas imagens
        const productId = card.getAttribute('data-id');
        if (!productId) {
            console.log(`‚ùå Card ${cardIndex}: ID do produto n√£o encontrado`);
            return;
        }

        console.log(`üîç Card ${cardIndex}: Verificando imagens do produto ${productId}...`);
        
        // Buscar dados do produto para verificar se tem m√∫ltiplas imagens
        this.checkProductImages(productId, card, cardIndex);
    }

    async checkProductImages(productId, card, cardIndex) {
        try {
            console.log(`üì° Buscando dados do produto ${productId}...`);
            
            // Buscar dados do produto do Firebase
            const productData = await this.fetchProductData(productId);
            
            if (!productData) {
                console.log(`‚ùå Produto ${productId}: Dados n√£o encontrados`);
                return;
            }

            console.log(`‚úÖ Produto ${productId}: Dados carregados`, productData);
            
            const images = this.extractImages(productData);
            console.log(`üñºÔ∏è Produto ${productId}: ${images.length} imagens encontradas`, images);
            
            if (images.length > 1) {
                console.log(`üé† Configurando troca de imagens para produto ${productId}...`);
                this.setupImageSwitching(card, images, cardIndex);
            } else {
                console.log(`‚ÑπÔ∏è Produto ${productId}: Apenas ${images.length} imagem, pulando troca`);
            }
        } catch (error) {
            console.error(`‚ùå Erro ao verificar imagens do produto ${productId}:`, error);
        }
    }

    async fetchProductData(productId) {
        // Buscar em todas as categorias e subcategorias
        const baseUrl = 'https://shopping-das-embalagens-default-rtdb.firebaseio.com/products.json';
        
        try {
            const response = await fetch(baseUrl);
            if (!response.ok) return null;
            
            const data = await response.json();
            
            // Procurar o produto em todas as categorias
            for (const categoria in data) {
                for (const subcategoria in data[categoria]) {
                    for (const id in data[categoria][subcategoria]) {
                        if (id === productId) {
                            return data[categoria][subcategoria][id];
                        }
                    }
                }
            }
            
            return null;
        } catch (error) {
            console.error('Erro ao buscar dados do produto:', error);
            return null;
        }
    }

    extractImages(productData) {
        const images = [];
        
        // Adicionar imagens se existirem
        if (productData.imageUrl) images.push(productData.imageUrl);
        if (productData.imageUrl2) images.push(productData.imageUrl2);
        if (productData.imageUrl3) images.push(productData.imageUrl3);
        
        return images;
    }

    setupImageSwitching(card, images, cardIndex) {
        const img = card.querySelector('.card-img-top');
        
        if (!img) return;

        console.log(`üé® Configurando troca de imagens para card ${cardIndex}...`);

        // Armazenar dados do carrossel
        this.carousels.set(cardIndex, {
            card: card,
            img: img,
            images: images,
            currentIndex: 0,
            intervalId: null,
            isHovering: false
        });
        
        console.log(`‚úÖ Troca de imagens configurada para card ${cardIndex} com ${images.length} imagens`);
        
        // Adicionar eventos de hover para iniciar/parar a troca
        this.addHoverEvents(card, cardIndex);
    }

    addHoverEvents(card, cardIndex) {
        card.addEventListener('mouseenter', () => {
            console.log(`üñ±Ô∏è Mouse entrou no card ${cardIndex}`);
            this.startImageSwitching(cardIndex);
        });
        
        card.addEventListener('mouseleave', () => {
            console.log(`üñ±Ô∏è Mouse saiu do card ${cardIndex}`);
            this.stopImageSwitching(cardIndex);
        });
    }

    startImageSwitching(cardIndex) {
        const carousel = this.carousels.get(cardIndex);
        if (!carousel) return;

        console.log(`‚ñ∂Ô∏è Iniciando troca de imagens do card ${cardIndex}`);
        carousel.isHovering = true;
        
        // Se j√° existe um intervalo, limpar primeiro
        if (carousel.intervalId) {
            clearInterval(carousel.intervalId);
        }

        // Iniciar a troca de imagens
        carousel.intervalId = setInterval(() => {
            this.nextImage(cardIndex);
        }, this.intervalTime);
    }

    stopImageSwitching(cardIndex) {
        const carousel = this.carousels.get(cardIndex);
        if (!carousel) return;

        console.log(`‚èπÔ∏è Parando troca de imagens do card ${cardIndex}`);
        carousel.isHovering = false;
        
        if (carousel.intervalId) {
            clearInterval(carousel.intervalId);
            carousel.intervalId = null;
        }

        // Voltar para a primeira imagem quando sair do hover
        carousel.currentIndex = 0;
        carousel.img.src = carousel.images[0];
    }

    nextImage(cardIndex) {
        const carousel = this.carousels.get(cardIndex);
        if (!carousel || !carousel.isHovering) return;

        const nextIndex = (carousel.currentIndex + 1) % carousel.images.length;
        console.log(`üîÑ Mudando para imagem ${nextIndex} do card ${cardIndex}`);
        
        // Atualizar √≠ndice atual
        carousel.currentIndex = nextIndex;
        
        // Trocar a imagem
        carousel.img.src = carousel.images[nextIndex];
    }

    observeNewCards() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Verificar se √© um card ou cont√©m cards (incluindo relacionados)
                        const cards = node.classList?.contains('card') || node.classList?.contains('related-card')
                            ? [node] 
                            : node.querySelectorAll?.('.card, .related-card');
                        
                        if (cards) {
                            console.log(`üÜï Novos cards detectados: ${cards.length}`);
                            cards.forEach((card, index) => {
                                const cardIndex = this.carousels.size + index;
                                this.setupCardCarousel(card, cardIndex);
                            });
                        }
                    }
                });
            });
        });

        // Observar mudan√ßas no container de produtos
        const productContainer = document.querySelector('.card-produtos') || 
                                document.querySelector('.containerItens') ||
                                document.querySelector('#featured-products') ||
                                document.querySelector('#produtos-relacionados-container');
        
        if (productContainer) {
            console.log('üëÄ Observando mudan√ßas no container de produtos');
            observer.observe(productContainer, {
                childList: true,
                subtree: true
            });
        }
    }

    // M√©todo p√∫blico para reinicializar carross√©is
    reinitialize() {
        console.log('üîÑ Reinicializando sistema de troca de imagens...');
        this.carousels.forEach((carousel, cardIndex) => {
            this.stopImageSwitching(cardIndex);
        });
        this.carousels.clear();
        this.setupCarousels();
    }
}

// Inicializar o sistema quando a p√°gina carregar
let imageCarousel;

document.addEventListener('DOMContentLoaded', function() {
    console.log('üìÑ DOM carregado, aguardando produtos...');
    // Aguardar um pouco para garantir que os produtos foram carregados
    setTimeout(() => {
        console.log('‚è∞ Iniciando sistema de troca de imagens ap√≥s delay...');
        imageCarousel = new ImageCarousel();
    }, 2000);
});

// Reinicializar quando produtos forem carregados dinamicamente
window.addEventListener('productsLoaded', function() {
    console.log('üì¶ Evento productsLoaded disparado');
    if (imageCarousel) {
        imageCarousel.reinitialize();
    }
});

console.log('‚úÖ Script de troca de imagens carregado');